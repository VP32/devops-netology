# Домашнее задание к занятию "Стратегии обновлений приложений"


### Задание 1. Выбрать стратегию обновления приложения и описать ваш выбор

1. Имеется приложение, состоящее из нескольких реплик, которое требуется обновить.
2. Ресурсы, выделенные для приложения ограничены и нет возможности увеличить
3. Запас по ресурсам в менее загруженный момент времени составляет 20%
4. Обновление мажорное, новые версии приложения не умеют работать со старыми
5. Какую стратегию обновления выберете и почему?

**Ответ:**

В зависимости от специфики использования приложения я бы использовал следуюшие стратегии:

 - **Recreate**: если допустима недоступность приложения. При таком обновлении мы не будем использовать дополнительные ресурсы, так как у нас нет возможности их увеличиить. Старые реплики будут уничтожены и запущены обновленные вместо них. Кроме того, если клиенты приложения также должны обновиться (например, фронт для бэка) и у них не будет обратной совместимости, то при успешном обновлении приложения клиент новой версии не столкнется со старой версией приложения. Старым клиентам надо будет сразу закрывать доступ.
 - **Canary update**: если недоступность приложения недопустима. При таком обновлении также не будут использованы дополнительные ресурсы. Указано, что у нас есть запас по ресурсам 20%. Как раз этот запас можно задействовать для поочередного обновления по 20% реплик. Но при этом необходимо разграничивать трафик от новых и старых клиентов приложения к обновленным и необновленным репликам. Постепенно при удачном обновлении все реплики обновятся, и старым клиентам будет закрыт доступ.

### Задание 2. Обновить приложение

1. Создать deployment приложения с контейнерами nginx и multitool. Версию nginx взять 1.19. Кол-во реплик - 5
2. Создать deployment приложения кеш с контейнером memcached. Версию memcached взять 1.6.0. Кол-во реплик - 5
3. Обновить версию nginx в приложении до версии 1.20 сократив время обновления до минимума. Приложение должно быть доступно
4. Обновить версию memcached в приложении до версии 1.6.5 сократив время обновления до минимума.
5. Попытаться обновить nginx до версии 1.28, приложение должно оставаться доступным
6. Откатиться после неудачного обновления

**Решение:**

1-2. Исходный манифест для двух деплойментов:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-multitool
  labels:
    app: nginx-multitool
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 80%
  selector:
    matchLabels:
      app: nginx-multitool
  template:
    metadata:
      labels:
        app: nginx-multitool
    spec:
      containers:
      - name: nginx
        image: nginx:1.19
        ports:
        - containerPort: 80
      - name: multitool
        image: wbitt/network-multitool
        ports:
        - containerPort: 8080
        env:
        - name: HTTP_PORT
          value: "8080"
        - name: HTTPS_PORT
          value: "11443"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cache
  labels:
    app: cache
spec:
  replicas: 5
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: cache
  template:
    metadata:
      labels:
        app: cache
    spec:
      containers:
      - name: memcached
        image: memcached:1.6.0
```

Применяю манифест, все успешно стартует:

![1.png](img%2F1.png)

3. Для обновления деплоймента с nginx применяю стратегию RollingUpdate, так как есть требование, чтобы приложение оставалось доступным.

Для сокращения времени обновления ставлю следуюее значение параметра:
maxUnavailable: 80% - будет сразу обновляться 80% реплик, то есть 4 реплики из 5. Одна реплика остается доступной. Параметр maxSurge: 25% оставляю по умолчанию, получается, что при обновлении дополнительно будет создана еще одна реплика. При успешном обновлении 4 реплик (и также создании новой по maxSurge) будет затем удалена оставшая старая реплика. 

Обновляю версию nginx в манифесте, применяю его:

```
    ...
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
    ...
```

Пошел процесс обновления, 4 реплики уничтожаются, пятая создается, одна старая доступна:
![2.png](img%2F2.png)

nginx успено обновлен:

![3.png](img%2F3.png)

4. Для обновления memcached использую стратегию Recreate, так как нет требования о постоянной доступности, и надо сократить время обновления до минимума.

Обновляю версию memcached в манифесте, применяю его: 

```
    ...
    spec:
      containers:
      - name: memcached
        image: memcached:1.6.5
    ...
```

Не успеваю поймать момент пересоздания подов с memcached, практически сразу пересоздаются успешно:

![4.png](img%2F4.png)

5. Пытаюсь обновить nginx до версии 1.28. Обновляю версию в манифесте, применяю его:


```
    ...
    spec:
      containers:
      - name: nginx
        image: nginx:1.28
    ...
```

Применяются изменения:

![5.png](img%2F5.png)

Пошли ошибки в 5 новых подах, 1 остается без обновления и продолжает работу:

![6.png](img%2F6.png)

6. С помощью команды `kubectl rollout undo deployment nginx-multitool` откатываю неудачное обновление:

начался откат обновления:
![7.png](img%2F7.png)

обновление успешно откатилось:
![8.png](img%2F8.png)


